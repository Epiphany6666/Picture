使用栅格系统完成导航栏布局

![image-20240225050628477](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251504641.png)

# 权限管理

我能够以一套通用的机制，去定义哪个页面需要哪些权限。

思路：

1. 在路由配置文件，定义某个路由的访问权限
2. 在全局页面组件中，绑定一个全局路由监听。每次访问页面时，根据用户要访问的路由信息，先判断用户是否有对应的访问权限
3. 如果有，跳转到原页面；如果没有，拦截或跳转到 401 鉴权或登录页

App.vue

~~~js
router.beforeEach((to, from, next) => {
  // 仅管理员可见，判断当前用户是否有权限
  if (to.meta?.access === 'canAdmin') {
    if (store.state.user.loginUser?.role !== 'admin') {
      next('/noAuth')
      return
    }
  }
  next()
  console.log(to)
})
~~~

底部 footer 布局优化

~~~css
/* .footer */
position: sticky;

/* a-layout：给父级元素添加，vh是相对于视口高度 */
min-height: 100vh;
~~~

优化缩小视口，导航栏出现换行的情况

~~~html
<a-row :wrap="false">
~~~

# 通用导航栏组件 - 根据配置控制菜单的显隐

错误写法：

1）给路由新增一个标志位，用于判断路由是否显隐

~~~js
{
    path: '/hide',
        name: '隐藏页面',
            component: HomeView,
                meta: {
                    hideInMenu: true
                }
}
~~~

2）不要用 v-for + v-if  去条件渲染，这样会先循环所有的元素，导致性能的浪费

~~~html
<div v-for="item in routes" :key="item.path">
    <a-menu-item :key="item.path" v-if="!item.meta?.hideInMenu">{{ item.name }}</a-menu-item>
</div>
~~~

经典的做法：先在js里将数组过滤

~~~js
const visibleRoutes = routes.filter((item) => {
  if (item.meta?.hideInMenu) {
    return false
  }
  return true
})
~~~

# 根据权限隐藏菜单

需求：只有具有权限的菜单，才对用户可见

原理：类似上面的控制路由显示隐藏，只要判断用户没有这个权限，就直接过滤



# 权限管理

1）定义权限，创建access/accessEnum.ts

~~~js
/**
 * 权限定义
 */
const accesssEnum = {
  NOT_LOGIN: 'notLogin',
  USER: 'user',
  ADMIN: 'admin'
}

export default accesssEnum
~~~

2）定义一个公用的权限校验方法

因为菜单组件中要判断权限，权限拦截也要用到权限判断功能，所以抽离公共办法

创建access/checkAccess.ts

~~~typescript
/**
 * 检查权限（判断当前登录用户是否具有某个权限
 * 1.需要知道当前用户有哪些权限
 * 2.要访问的这个页面需要什么权限
 * @param loginUser 当前登录用户
 * @param needAccess
 * @return 有无权限
 */
import ACCESS_ENUM from './accessEnum'

// 如果访问这个页面不需要权限，将它定为 ACCESS_ENUM.NOT_LOGIN 即可
const checkAccess = (loginUser: any, needAccess = ACCESS_ENUM.NOT_LOGIN) => {
  // 判断当前登录用户具有的权限（如果没有 loginUser，则表示未登录）
  const loginUserAccess = loginUser?.userRole ?? ACCESS_ENUM.NOT_LOGIN
  if (needAccess === ACCESS_ENUM.NOT_LOGIN) {
    return true
  }
  // 如果用户登录才能访问
  if (needAccess === ACCESS_ENUM.USER) {
    // 如果用户没登录，那么表示无权限
    if (loginUserAccess !== ACCESS_ENUM.NOT_LOGIN) {
      return false
    }
  }
  // 如果需要管理员权限
  if (needAccess === ACCESS_ENUM.ADMIN) {
    // 如果不为管理员，表示无权限
    if (loginUserAccess !== ACCESS_ENUM.ADMIN) {
      return false
    }
  }
  // 其他情况返回true
  return true
}

// 如果这个文件只有一个方法要导出，则使用export default就可以了
export default checkAccess
~~~

3）修改 GlobalHeader 动态菜单组件，根据权限来过滤菜单

注意，这里使用计算属性，是为了当登录用户信息发生变更时，触发菜单栏的重新渲染，展示新增权限的菜单项

~~~js
const visibleRoutes = computed(() => {
  const loginUser = store.state.user.loginUser
  return routes.filter((item) => {
    if (item.meta?.hideInMenu) {
      return false
    }
    // 根据权限过滤菜单
    if (!checkAccess(loginUser, item.meta?.access as string)) {
      return false
    }
    return true
  })
})
~~~

# 全局项目入口

App.vue 中预留一个可以编写全局初始化逻辑的代码

~~~js
/**
 * 全局初始化函数，有全局单次调用的代码，都可以写到这里
 */
const doInit = () => {
  console.log('hello 欢迎来到我的项目')
}

onMounted(() => {
  doInit()
})
~~~



# 后端项目初始化

三种初始化Java项目的方式

1. GitHub搜现成的代码
2. SpringBoot 官方的模板



## 使用模板步骤：

1）全局替换 springboot-init为项目名（youj-backend）

ctrl + shift + F：全局查找springboot-init

ctrl + shift + R：全局替换

![image-20240225114610800](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505087.png)

2）全局替换springbootinit 包名为新的包名（youj）

ctrl + shift + F：springbootinit

![image-20240225114802710](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505289.png)

3）修改 springbootinit 文件夹的名称为新的包名对应的名称（youj）

shift + F6：包名改成youj

![image-20240225114921453](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505322.png)

重命名项目名：shift + F6

![image-20240225115128406](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505267.png)

修改数据配置

![image-20240225115230222](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505953.png)

直接搜索todo，出来的都是需要配置的，如果需要直接搜索就行

![image-20240225115313241](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505026.png)

4）修改数据库名

![image-20240225120658695](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505866.png)

​	然后直接全选点执行

![image-20240225120514707](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505841.png)

![image-20240225120536323](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505343.png)

5）修改端口号（8121）



1）先阅读 README.md

2）sql/create_table.sql 定义了数据库的初始化建库建表语句



首先下载axios

~~~shell
npm install axios
~~~

yapi：基于接口文档自动生成代码的工具。

自动生成工具：https://github.com/ferdikoomen/openapi-typescript-codegen

首先安装：

```shell
npm install openapi-typescript-codegen --save-dev
```

--input：指定接口文档的路径、url 或字符串内容（必填）

--output：代码生成的目录

--client：生成的代码所需要使用的请求库

```shell
openapi --input http://localhost:8121/api/v2/api-docs --output ./generated --client axios
```

![image-20240225133608737](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505821.png)

直接使用生成的Service代码，直接调用函数发送请求即可

~~~ts
import { UserControllerService } from '../../generated/services/UserControllerService'
actions: {
    async getLoginUser({ commit, state }, payload) {
        // 从远程获取登录信息
        const res = await UserControllerService.getLoginUserUsingGet()
        if (res.code === 0) {
            commit('updateUser', res.data)
        } else {
            commit('updateUser', { ...state.loginUser, userRole: ACCESS_ENUM.NOT_LOGIN })
        }
    }
}
~~~



## 自定义请求参数的方法

### 1）使用代码生成器提供的全局参数修改对象

https://github.com/ferdikoomen/openapi-typescript-codegen/wiki/OpenAPI-object

![image-20240225160144294](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251601529.png)

![image-20240225160309555](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251603593.png)

![image-20240225160327610](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251603713.png)

其中BASE可以修改请求地址

![image-20240225160623676](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251606750.png)

### 2）直接定义 axios 请求库的全局参数，比如：全局请求响应拦截器

https://www.axios-http.cn/docs/interceptors

src/plugins/axios.ts

~~~ts
import axios from 'axios'

// 添加请求拦截器
axios.interceptors.request.use(
  function (config) {
    // 在发送请求之前做些什么
    return config
  },
  function (error) {
    // 对请求错误做些什么
    return Promise.reject(error)
  }
)

// 添加响应拦截器
axios.interceptors.response.use(
  function (response) {
    console.log('响应', responses)

    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response
  },
  function (error) {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    return Promise.reject(error)
  }
)
~~~

在main.ts中引入

~~~ts
import '@/plugins/axios'
~~~





![image-20240225133912618](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505273.png)

![image-20240225135104449](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505374.png)

JSON格式化插件

![image-20240225134110422](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505948.png)

![image-20240225134234652](https://cdn.jsdelivr.net/gh/Epiphany6666/Picture/blog/%E5%89%8D%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/assets/202402251505985.png)

---

# 用户登录功能

## 自动登录

1）在 store/user.ts 中获取远程登录用户信息的代码

~~~ts
async getLoginUser({ commit, state }, payload) {
    // 从远程获取登录信息
    const res = await UserControllerService.getLoginUserUsingGet()
    if (res.code === 0) {
        commit('updateUser', res.data)
    } else {
        commit('updateUser', { ...state.loginUser, userRole: ACCESS_ENUM.NOT_LOGIN })
    }
}
~~~

2）在哪里去触发 getLoginUser 函数的执行？应当在一个全局的位置

有很多选择：

1. 路由拦截
2. 全局页面入口 App.vue
3. 全局通用布局（所有页面都共享的组件）



# 全局权限管理优化

1）新建  access\index.ts 文件，把原有的路由拦截、权限校验逻辑放在独立的文件中

优势：只要不引入、就不会开启、不会对项目有影响

userRouter()和useStore()是不能直接在js文件中引用的

2）编写权限管理和自动登录逻辑



如果没登路过，自动登录

~~~ts
const loginUser = store.state.user.loginUser
// 如果之前没登陆过，自动登录
if (!loginUser || !loginUser.role) {
    // 加 await 是为了等用户登录成功之后，再执行后续的代码，这样就可以保证刚刚进行登录，也可以进行权限校验了
    await store.dispatch('getLoginUser')
}
~~~



如果用户访问的页面不需要登录，是否需要强制跳转到登录页？

答：不需要



acces\index.ts 实例代码：

~~~ts
import router from '@/router'
import store from '@/store'
import ACCESS_ENUM from './accessEnum'
import checkAccess from './checkAccess'

router.beforeEach(async (to, from, next) => {
  console.log('登录用户信息')

  // 仅管理员可见，判断当前用户是否有权限
  if (to.meta?.access === 'canAdmin') {
    if (store.state.user.loginUser?.role !== 'admin') {
      next('/noAuth')
      return
    }
  }

  const loginUser = store.state.user.loginUser
  // 如果之前没登陆过，自动登录
  if (!loginUser || !loginUser.role) {
    // 加 await 是为了等用户登录成功之后，再执行后续的代码，这样就可以保证刚刚进行登录，也可以进行权限校验了
    await store.dispatch('getLoginUser')
  }
  // 要跳转的页面不需要登录
  const needAccess = (to.meta?.access as string) ?? ACCESS_ENUM.NOT_LOGIN
  // 如果没登录，直接跳转到登录页面
  if (needAccess !== ACCESS_ENUM.NOT_LOGIN) {
    if (!loginUser || !loginUser.userRole) {
      next(`user/login?redirect=${to.fullPath}`)
    }
    // 如果已经登录了，但是权限不足，那么跳转到无权限页面
    if (!checkAccess(loginUser, needAccess)) {
      next('/noAuth')
    }
  }
  next()
})
~~~



ctrl + r：替换



## 支持多套布局

1）在 routes 路由文件中新建一套用户路由，使用 vue-router 自带的子路由机制，实现布局和嵌套路由

~~~ts
{
    path: '/user',
    name: '用户',
    component: UserLayout,
    children: [
      {
        path: '/user/login',
        name: '用户登录',
        component: UserLoginView
      },
      {
        path: '/user/register',
        name: '用户注册',
        component: UserRegisterView
      }
    ]
  },
~~~

2）新建 UserLayout、UserLoginView、UserRegisterView 页面，并写在 routes 中引入

3）在 app.vue 根页面文件，根据路由去区分多套布局

~~~html
<template v-if="route.path.startsWith('/user')">
    <router-view></router-view>
</template>
<template v-else>
    <BasicLayout />
</template>
~~~

当前这种 app.vue 中通过 if else 区分布局的方式，不是最优雅的，理想情况下直接读取 routes.ts，在这个文件中定义多套布局，然后自动使用页面布局。





























